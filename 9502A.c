#pragma config(Sensor, in8,    gyro,     sensorGyro)
#pragma config(Sensor, dgtl1,  goalLiftPistons, sensorDigitalOut)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftMotors,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           turretMotors,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           verticalClaw,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TEAM_A
#include "../Include/LCD3.0.c"

// -----------------------------------------------------------------
// -------------------- ROBOTC Competition Code --------------------
// -----------------------------------------------------------------

#pragma platform(VEX2)
#pragma competitionControl(Competition)]
#include "Vex_Competition_Includes.c"

// -----------------------------------------------------------------
// --------------------    Global  Variables    --------------------
// -----------------------------------------------------------------

int deadZone(int inputVal, int thresholdVal)
{
	if(fabs(inputVal) > thresholdVal)
	{
		return inputVal;
	}
	else
	{
		return 0;
	}
}

// -----------------------------------------------------------------
// --------------------   Pre-Autonomous Code   --------------------
// -----------------------------------------------------------------

void pre_auton()
{
  bStopTasksBetweenModes = true;
  bDisplayCompetitionStatusOnLcd = false;

  // Reset Robot
  displayLCDCenteredString(0, " Calibrating... ");
  displayLCDCenteredString(1, "  Don't Touch!  ");
  bLCDBacklight = false;

  // Pneumatic Pistons
  SensorValue[goalLiftPistons] = 0;

 	// Gyro
	SensorType[in8] = sensorNone;
 	wait1Msec(1000);
 	SensorType[in8] = sensorGyro;
 	wait1Msec(2000);

  setLCDRefreshRate(10);

  startTask(autonomousSelector);

	//End pre-auton
	return;
}

// -----------------------------------------------------------------
// --------------------     Autonomous Code     --------------------
// -----------------------------------------------------------------

task autonomous()
{
	switch(routineNum)
	{
		case 0:
		{
			//Do nothing
			break;
		}
		case 1:
		{
			rightMobileGoal();
			break;
		}
		case 2:
		{
			testAutonomous();
			break;
		}
		default:
		{
			break;
		}
	}
	return;
}

// -----------------------------------------------------------------
// --------------------   Driver Control Code   --------------------
// -----------------------------------------------------------------

task usercontrol()
{
	int x = 0;
	int y = 0;
	int r = 0;

	while(true)
	{
		//----------------------
		// Primary Controller
		//----------------------

		//Drivetrain

		if(vexRT[Btn5U] == 1)
		{
			r = -64;
		}
		else if(vexRT[Btn6U] == 1)
		{
			r = 64;
		}
		else
		{
			r = 0;
		}

		x = deadZone(vexRT[Ch4], 16);
		y = deadZone(vexRT[Ch3], 16);
		motor[frontLeft] = -x - y + r;
		motor[backLeft] = x - y + r;
		motor[frontRight] = -x + y + r;
		motor[backRight] = x + y + r;

		//----------------------
		// Partner Controller
		//----------------------

		//Pistons
		//0 = Up
		//1 = Down
		if(vexRT[Btn6UXmtr2] == 1)
		{
			//Raise the piston lift
			SensorValue[goalLiftPistons] = 0;
			SensorValue[goalLiftPistons] = 0;
		}
		else if(vexRT[Btn5UXmtr2] == 1)
		{
			//Lower the piston lift
			SensorValue[goalLiftPistons] = 1;
			SensorValue[goalLiftPistons] = 1;
		}
		else
		{
			//Don't do anything, leave the piston where it is
			EndTimeSlice();
		}

		// Claw
		// - = open claw
		// + = close claw
		if(vexRT[Btn8UXmtr2] == 1)
		{
			motor[clawMotor] = -48;
		}
		else if(vexRT[Btn8DXmtr2] == 1)
		{
			motor[clawMotor] = 48;
		}
		else
		{
			motor[clawMotor] = 0;
		}

		// Vertical claw
		// - = Up
		// + = Down
		if(vexRT[Ch2Xmtr2] > 0)
		{
			motor[verticalClaw] = -(deadZone(vexRT[Ch2Xmtr2], 16) / 1.0);
		}
		else if(vexRT[Ch2Xmtr2] < 0)
		{
			motor[verticalClaw] = -(deadZone(vexRT[Ch2Xmtr2], 16) / 2.0);
		}

		//Lift
		// + = up
		// - = down
		motor[liftMotors] = deadZone(vexRT[Ch3Xmtr2], 24);

		//Turret
		// + = clockwise
		// - = counterclockwise
		motor[turretMotors] = deadZone(vexRT[Ch4Xmtr2], 16);
	}
}

// -----------------------------------------------------------------
